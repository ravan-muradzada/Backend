#authentication #otp #jwt #rate-limit #passport-js 

## **One Time Password (OTP) logic**

##### What is OTP and how to generate it?
While signing up, mostly we require unique specifiers like email or phone number to differ our users. However, it is a threat that some users can use others email or phone number to sign up and this is a bad strategy in terms of authorization. To prevent this kind of situations, we use OTP logic. So after user enters an email, we send the verification code to this email and want user to say us the code. If he can type correct code, we assume this email is his and he read our mail and enter it. Otherwise, this means this is not his email.
To implement this kind of logic, we can use platforms like **SendGrid** which helps us to send mails to specified email accounts. 
It might be a good strategy to send this emails also in logging in process, to be sure he is the owner of the email, because the real user may leak his password and using this method we can preclude this kind of situations. 
Generating OTP code is very easy, we can use random number (or character) generator specific to other languages or libraries like `otp-generator` (in node).

```javascript
import otpGenerator from 'otp-generator';
const otpCode = otpGenerator.generate();
```

##### Routers and controllers design
While implementing routers for signing up and want to add otp logic, I will recommend one of the methods. We mainly need two routers. In the first router (`/sign-up`) , we just need an email from the user and create an otp code. To be able check this otp code in other routers, we need to save it with uniqeu specifier (of course, with email!). For this kind of tasks, it is good to use redis.
```javascript
const { email } = req.body;
const otpKey = `OTP_SIGN-UP:${email}`;

// If we want to allow one otp:
await redisClient.set(otpKey, otpCode, { EX: 300 });

// Or, if we want to allow multiple otps:
await redisClient.lPush(otpKey, otpCode);
await redisClient.expire(otpKey, 300);
```

In the second controller (`/verify-otp`), we need to have an email of user and input otp code by user candidate. After getting email, we check input otp with the real otp (generated by us) from redis.

```javascript
const { email, inputOtp } = req.body;
const otpKey = `OTP_SIGN-UP:${email}`;

// If we allow to have one otp:
const realOtp = await redisClient.get(otpKey);
const checkExistenceOfOtp = (inputOtp === realOtp);

// If we allow to have multiple otp:
const allOtps = await redisClient.lRange(otpKey, 0, -1);
const checkExistenceOfOtp = allOtps.includes(inputOtp);

if (!checkExistenceOfOtp) {
	// Error message
} else {
	// Successfull
}

await redisClient.del(otpKey);
```


## **Json Web Token (JWT) logic**

##### Usage of JWT
A JSON Web Token (JWT) is a standard used to securely transmit information between a client (like a frontend application) and a server (the backend). It is commonly used to verify users' identities, authenticate them, and ensure safe communication between the two. JWTs are mainly used in web apps and APIs to protect against unauthorized access.

##### Implementations of JWT tokens
In main implementation of JWT logic, we use two tokens; refresh and access tokens.
When the user logs in or signs up, two tokens are created in the server. Access token (short-life period) is sent to frontend in the response body and frontend saves it and sends back to the server in each request to verify user. However, refresh token (long-life period) is first saved in **redis** with unique specifier and then to frontend as cookie (frontend cannot modify it). 
For access tokens there are short period to live and after each this period, frontend send the request to `/refresh` endpoint of the server in the part access token is recreated and sent back to the server as response body. While this process, to verify the user, we check refresh token in the cookie.

```javascript
const generateToken = async (userId) => {
    try {
	    // Session id is used, because the user can log in from different devices at the same time. To handle their jwt process seperately, we use it.
        const sessionId = uuidv4();

        const accessToken = jwt.sign({ userId, sessionId }, 
        process.env.ACCESS_TOKEN_SECRET, { expiresIn: '15m' });
        
        const refreshToken = jwt.sign({ userId, sessionId }, 
        process.env.REFRESH_TOKEN_SECRET, { expiresIn: '7d' });

		// It is good to save refresh token in the redis hashed.
        const hashedRefreshToken = await bcrypt.hash(refreshToken, 8);
        
        const keyForRefreshToken = `REFRESH_TOKEN:${userId}:${sessionId}`;
        await redis.set(keyForRefreshToken, hashedRefreshToken, { EX: 7 * 24 * 60 * 60 });
          
        return { accessToken, refreshToken };
    } catch(e) {
        console.log(chalk.red.bold('Error occurred while generating jwt! '), e.message);
        throw new Error('Failed to generate jwt!');
    }
}
```

```javascript
// Attach a refresh token to a cookie
res.cookie('refreshToken', refreshToken, {
    httOnly: true,
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60
});

// Sending response
res.status(201).json({
    success: true,
    accessToken
});
```

#### What does happen while logging out?
The access token should be removed from frontend and it might be to add  this token to blacklist in backend not to use this again. We also need to remove a refresh token from both redis and cookie:

```javascript
const removeOneRefreshToken = async (userId, sessionId) => {
    try {
        const key = `REFRESH_TOKEN:${userId}:${sessionId}`;
        await redis.del(key);

        console.log(chalk.green.bold('The refresh token removed successfully!'));
        return true;
    } catch(e) {
        console.log(chalk.red.bold('Error occurred while removing the refresh
        token! ', e.message));
        throw new Error('Failed to remove the refresh token!');
    }
}
```

```javascript
res.clearCookie('refreshToken', {
    httOnly: true,
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60
});
```

##### Whenever we change or reset the password
When we change or reset our password, automatically our account should log out from all devices. For that, we need to remove all refresh tokens from the redis and cookie. (Then it is better to add them to blacklist).
```javascript
const removeRefreshTokensFromRedis = async (userId) => {
    try {
        const keys = redis.keys(`REFRESH_TOKEN:${userId}`);

        if (keys.length > 0) {
            await redis.del(...keys);
        }

        console.log(chalk.green.bold('All refresh tokens removed successfully!'));
        return true;
    } catch(e) {
        console.log(chalk.red.bold('Error occurred while removing refresh tokens!
        ', e.message));
        throw new Error('Failed to remove refresh tokens');
    }
}
```

```javascript
// It is not possible to remove all cookies, but because they are useless now.
res.clearCookie('refreshToken', {
    httOnly: true,
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60
});
```

##### Refreshing the tokens
We need to implement a refresh router to refresh all tokens periodically. 
```javascript
export const refresh = async (req, res) => {
    try {
        const oldRefreshToken = req.cookies.refreshToken;
        if (!oldRefreshToken) {
            return res.status(401).json({
                success: false,
                message: 'Refresh Token not found!'
            });
        }

        const payload = jwt.verify(oldRefreshToken,
        process.env.REFRESH_TOKEN_SECRET);
        const userId = payload.userId, sessionId = payload.sessionId;

        const refreshTokenInRedis = await 
        redis.get(`REFRESH_TOKEN:${userId}:${sessionId}`);
        
        if (!refreshTokenInRedis) {
            return res.status(401).json({
                success: false,
                message: 'Refresh Token not found!'
            });
        }

		// Removing refresh token from redis
        await handleTokens.removeOneRefreshToken(userId, sessionId); 

        const checkMatching = await bcrypt.compare(oldRefreshToken,
        refreshTokenInRedis);

        if (!checkMatching) {
            return res.status(400).json({
                success: false,
                message: 'Refresh Token does not match!'
            });
        }

        // Generating and getting tokens
        const { accessToken, refreshToken } = await
        handleTokens.generateToken(userId);

        // Attaching a refresh token to a cookie
        res.cookie('refreshToken', refreshToken, {
            httOnly: true,
            sameSite: 'strict',
            maxAge: 7 * 24 * 60 * 60
        });

        res.status(200).json({
            success: true,
            message: 'Tokens have been refreshed!',
            accessToken
        });
    } catch(e) {
        res.status(400).json({
            success: false,
            message: `Error occurred while refreshing the tokens! ${e.message}`
        });
    }
}
```


## **Passport.js and OAuth**
It is well known method to add methods to sign up or log in with Google, Facebook, Github and etc.
To be able to implement it, we have a powerfull tool which is `Passport.js`. We can check its website and see tons of strategies and use them. One of the most popular strategies is Google.
To be able to use any strategy, we need to download this package in Node:
`npm i passport` and then download strategy-specific library which is shows in its page in the website. For Google, we use `npm i passport-google-oauth20`. 
It is good to create specific folder inside `src/` with the  name like `auth/`. Inside it we will have another folder named `strategies/` which includes all the strategies we want to have and `index.js` file which combine all strategies together.
We can use something like that:
```javascript
import passport from "passport";
import { Strategy as GoogleStrategy } from "passport-google-oauth20";
import prisma from "../../config/db.js";

passport.use(
  new GoogleStrategy(
    {
      clientID: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
      callbackURL: "/auth/google/callback",
    },
    async (AccessToken, refreshToken, profile, done) => {
      try {
        const googleId = profile.id;
        const email = profile.emails[0].value;
        const name = profile.displayName;

        let user;
        try {
          user = await prisma.user.findUnique({
            where: {
              email,
            },
          });
        } catch (error) {
          return done(new Error("Error fetching user from the database"), null);
        }

        if (!user) {
          user = await prisma.user.create({
            data: {
              email,
              googleId,
              name
            }
          });
        }

        const userId = user.id;

        done(null, { userId });
      } catch (e) {
        done(e.message, null);
      }
    }
  )
);
```

Inside `index.js` in `auth/`, we write this:
```javascript
import passport from 'passport';

// All strategies here
import './strategies/passport-google.js';

export default passport;
```

Lastly, in our `server.js` file:
```js
import passport from './auth/index.js';
app.use(passport.initialize());
```

## **Rate Limiting**
Sometimes, a user can send a lot of request to the server which is bad for our server. So it is a good idea to block requests after a while. In this case, for each router we want to implement rate limiting process, we need to use rate-limiter. We use specific library for it:
```bash
npm i express-rate-limit
```

I have created two rate limiters, one for sensitive routers which allows less requests and another for other routers which allows more requests. 
```javascript
export const sensitiveRouteLimiter = rateLimit({
    windowMs: 15*60*1000, // How long to remember requests, refresh after this amoung of time (ms)
    max: 10, // Max number of requests in this time period
    message: { // Error message when rate limit is exceeded
        success: false,
        message: 'Too many attempts for sensitive router, try again later!'
    }
});

export const protectedRouteLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100,
    message: {
        success: false,
        message: 'Too many attempts for protected route, try again later!'
    }
});
```
We just need to import it in routers file and use as a regular middleware, however the main thing is this should be our first middleware for each router.

## **Account Freezing**
While logging in process, hackers can try to use brute-force method to find correct password for the account and for that they will try the password a lot of times. To slow down and make this method unsuccessfull we can use account freezing method. Basically, it freezes the account after some number of requests and in this time you cannot send request to the server. 
After each unsuccessful request, our server increments the number of failed requests and save it in redis with the unique specifier. As unique specifier, we use `email` and ip of the user. We implement this logic as regular middleware.
```js
const loginFreezeMiddleware = async (req, res, next) => {
    try {
        const { email } = req.body;
        const key = `fail-in-login:${email}:${req.ip}`;
        const unsuccessfulLoginAttempts = await redis.get(key) || 0;

        if (unsuccessfulLoginAttempts > 10) {
            return res.status(429).json({
                success: false,
                message: 'Too many requests!'
            });
        }

        next();
    } catch(e) {
        console.log(`Error happened in login freezing middleware: ${e.message}`);
        res.status(400).json({
            success: false,
            message: `Something went wrong while login freezing! ${e.message}`
        });
    }
}

export default loginFreezeMiddleware;
```

We create this as a seperate middleware file and call for the `/login` router.

In `/login` router whenever it is determined that the password is wrong, we can increment the counter:
```js
const isCorrectPassword = await bcrypt.compare(password, user.password);

if (!isCorrectPassword) {
    const key = `fail-in-login:${email}:${req.ip}`;
    const attempts = await redis.incr(key);
    
    if (attempts === 1) {
	    await redis.expire(key, 10*60);
	}

	return res.status(400).json({
	    success: false,
	    message: 'Wrong in credentials!'
	});
}
```

## **Forget Password**
While logging in some user may forget their password to enter their account. If we do not implement `Forget Password` feature, they just lose their accounts permanently. 
In this method, user just clicks it and this sends a reset link to his email. When he clicks it, he will redirect to another page where he can enter new password here. Then he just needs to log in regularly with his new password.
```js
export const forgetPassword = async (req, res) => {
    try {
        const { email } = req.body;

        const user = await prisma.user.findUnique({
            where: {
                email
            }
        });

        if (!user) { 
            return res.status(404).json({
                success: true,
                message: 'User with this email not found!'
            });
        }

        if (user.provider === 'google') {
            return res.status(400).json({
                success: false,
                message: 'You cannot change the password, because you registered                    via Google!'
            });
        }

        const token = crypto.randomBytes(32).toString('hex');
        await redis.set(`reset:${token}`, user.id, 'EX', 60 * 15);
        console.log(`Token: ${token}`);

        const resetLink = `http://localhost:3000/reset-password/:${token}`;

        // Sending email
        const subject = 'Password Reset';
        const html = `<a href="${resetLink}">Reset Your Password</a>`;
        await msgSender.sendMail(email, subject, 'undefined', html);
        
        res.status(200).json({
            success: true,
            message: 'Email sent successfully!'
        });
    } catch(e) {
        res.status(400).json({
            success: false,
            message: `Error happened while sending reset link to your email!                  ${e.message}`
        });
    }
}
```
We will just need to create another route to get new password and we need to check the token verify the user.

```js
export const resetPassword = async (req, res) => {
    try {
        const { token } = req.params;
        const { newPassword } = req.body;

        const hashedPassword = await bcrypt.hash(newPassword, 8);

        const id = await redis.get(`reset:${token}`);

        if (!id) {
            return res.status(404).json({
                success: false,
                message: 'Invalid or expired token!'
            });
        }

        const updatedUser = await prisma.user.update({
            where: {
                id: parseInt(id)
            },
            data: {
                password: hashedPassword
            }
        });

        await redis.del(`reset:${token}`);
        await handleTokens.removeRefreshTokensFromRedis(id);
        
        res.status(200).json({
            success: true,
            message: 'Password reset successfully!'
        });
    } catch(e) {
        res.status(400).json({
            success: false,
            message: 'Error happened while resetting the password'
        });
    }
}
```